### DO NOT EDIT THIS FILE ###

from pypdevs.DEVS import AtomicDEVS
import random

# ============================================================================
# NOTE: This version of PyPDEVS requires outputs to be wrapped in lists.
# You will see [value] instead of just value in outputFnc() methods.
# Inputs are automatically unwrapped, but we check with isinstance() to be safe.
# See the comments in atomicdevs.py for more details.
# ============================================================================

class Product:
    """
    Represents a product in the manufacturing system.
    
    Attributes:
        product_type (int): The type identifier for this product (products of the same type can be batched)
        size (int): The size of the product (e.g., 1 or 2)
        recipe (list): The sequence of machine operations (e.g., ['A', 'B'] or ['B', 'A'])
        processing_times (dict): Processing time for each machine in recipe (e.g., {'A': 900, 'B': 600})
        current_step (int): The current step in the recipe (0-indexed)
        arrival_time (float): The time when the product entered the system
    """
    def __init__(self, product_type, size, recipe, processing_times, creation_time):
        self.product_type = product_type
        self.size = size
        self.recipe = recipe
        self.processing_times = processing_times
        self.current_step = 0
        self.arrival_time = creation_time
    
    def __repr__(self):
        return f"Product(type={self.product_type}, size={self.size}, recipe={self.recipe}, step={self.current_step})"

class GeneratorState:
    def __init__(self, seed=0):
        # Current simulation time
        self.current_time = 0.0
        # Remaining time until generation of new product
        self.remaining = 0.0
        # Next product to output
        self.next_product = None
        # State of our random number generator
        self.random = random.Random(seed)

class Generator(AtomicDEVS):
    """
    Generator creates products at pseudo-random time intervals (infinitely).
    
    Parameters:
        seed (int): Seed for the random number generator
        lambd (float): Rate parameter for exponential distribution (products/second)
        gen_types (list of tuples): List of (product_type, size, recipe, processing_times, probability) tuples
                                     E.g., [(0, 1, ['A', 'B'], {'A': 900, 'B': 600}, 2/3), 
                                            (1, 2, ['B', 'A'], {'A': 1200, 'B': 800}, 1/3)]
    
    Output Ports:
        out_product: Outputs a Product object when generated
    """
    def __init__(self, seed=0, lambd=1.0/60.0/4.0, gen_types=[(0, 1, ['A', 'B'], {'A': 900, 'B': 600}, 2/3), (1, 2, ['B', 'A'], {'A': 1200, 'B': 800}, 1/3)]):
        super().__init__("Generator")
        
        # Output port for the product
        self.out_product = self.addOutPort("out_product")
        
        # Parameters
        self.lambd = lambd
        self.gen_types = gen_types
        
        # Initialize state
        self.state = GeneratorState(seed)
        self._nextProduct()  # Schedule the first product
    
    def _nextProduct(self):
        # Randomly select a product type based on probabilities
        types = [t[:4] for t in self.gen_types]  # Extract (product_type, size, recipe, processing_times) tuples
        weights = [t[4] for t in self.gen_types]  # Extract probabilities
        product_type, size, recipe, processing_times = self.state.random.choices(types, weights=weights)[0]
        # Calculate creation time
        creation = self.state.current_time + self.state.remaining
        # Update state
        self.state.next_product = Product(product_type, size, recipe, processing_times, creation)
        self.state.remaining = self.state.random.expovariate(self.lambd)
    
    def intTransition(self):
        # Update simulation time
        self.state.current_time += self.timeAdvance()
        # Generate next product (infinitely)
        self._nextProduct()
        return self.state
    
    def timeAdvance(self):
        # Return remaining time; infinity when generated enough
        return self.state.remaining
    
    def outputFnc(self):
        # Output the new product on the output port (wrap in list for PyPDEVS)
        return {self.out_product: [self.state.next_product]}


class SinkState:
    def __init__(self, target_num):
        # Contains received products and simulation time
        self.products = []
        self.current_time = 0.0
        self.target_num = target_num  # Number of finished products needed to terminate

class Sink(AtomicDEVS):
    """
    Sink collects finished products and computes statistics.
    
    For each product, it computes the total time spent in the system
    (current_time - arrival_time).
    
    The simulation terminates when the sink receives target_num finished products.
    
    Parameters:
        target_num (int): Number of finished products required to terminate simulation
    
    Input Ports:
        in_product: Receives finished Product objects
    """
    def __init__(self, target_num=500):
        super().__init__("Sink")
        self.state = SinkState(target_num)
        # Has only one input port
        self.in_product = self.addInPort("in_product")
    
    def extTransition(self, inputs):
        # Update simulation time
        self.state.current_time += self.elapsed
        # Get the product
        product = inputs[self.in_product]
        # PyPDEVS unwraps single-element lists automatically
        if isinstance(product, list):
            product = product[0]
        # Calculate time in system (flow time)
        flow_time = self.state.current_time - product.arrival_time
        product.flow_time = flow_time
        # Add incoming product to received products
        self.state.products.append(product)
        return self.state
    
    def finished_products_count(self):
        """
        Count finished (non-spoiled) products.
        For base assignment, all products are finished.
        For bonus, check is_spoiled attribute.
        """
        count = 0
        for p in self.state.products:
            if not hasattr(p, 'is_spoiled') or not p.is_spoiled:
                count += 1
        return count
    
    def termination_condition(self):
        """
        Returns True when enough finished products have been received.
        """
        return self.finished_products_count() >= self.state.target_num

### END OF PROVIDED CODE - DO NOT EDIT ###
